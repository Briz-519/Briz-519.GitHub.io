<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://briz-519.github.io</id>
    <title>Briz&apos;s home of notes</title>
    <updated>2020-08-11T10:24:50.141Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://briz-519.github.io"/>
    <link rel="self" href="https://briz-519.github.io/atom.xml"/>
    <subtitle>This is a site I use to store my notes</subtitle>
    <logo>https://briz-519.github.io/images/avatar.png</logo>
    <icon>https://briz-519.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Briz&apos;s home of notes</rights>
    <entry>
        <title type="html"><![CDATA[Python1.0]]></title>
        <id>https://briz-519.github.io/post/python10/</id>
        <link href="https://briz-519.github.io/post/python10/">
        </link>
        <updated>2020-08-11T10:19:48.000Z</updated>
        <content type="html"><![CDATA[<p>#号为注释</p>
<pre><code class="language-python"># this is a comment text
</code></pre>
<p>多行注释<code>''' '''</code></p>
<pre><code class="language-python">'''
这是一行注释
这也是一行注释
'''
</code></pre>
<p>IDLE为Python的交互式界面也叫做shell界面</p>
<p>交互式-- 一问一答的解释性语言（一行一行的执行）</p>
<p>print(你需要输出的语句)</p>
<pre><code class="language-python">&gt;&gt;&gt;print(&quot;This is my first experience to study python language&quot;)
This is my first experience to study python language
&gt;&gt;&gt;print(1+2)
3

print(&quot;www&quot;,&quot;baidu&quot;,&quot;com&quot;,sep=&quot;.&quot;)  #以.作为连接符，输出：www.bai.com
print(&quot;hello&quot;,end=&quot;&quot;)      #end 以什么结束，若为空则不换行连接输出
print(&quot;world&quot;,end=&quot;\t&quot;)   #该语句输出：helloworld    python
print(&quot;python&quot;)
</code></pre>
<p>*用在字符串里表示重复操作符</p>
<pre><code class="language-python">&gt;&gt;&gt;print(&quot;fuck&quot;*3)
fuckfuckfuck
</code></pre>
<p>input()输入函数</p>
<pre><code class="language-python">&gt;&gt;&gt;t=input(&quot;test&quot;)
&gt;&gt;&gt;print(t)
test
</code></pre>
<p>input输入的均为字符串，若想输入其他形式则先强制进行转换</p>
<pre><code class="language-python">&gt;&gt;&gt;x=int(input(&quot;123&quot;))
&gt;&gt;&gt;print(x)
123
</code></pre>
<pre><code class="language-python">&gt;&gt;&gt;a=1
&gt;&gt;&gt;type(a)  #输出a的数据类型
&gt;&gt;&gt;&lt;class 'int'&gt;    #class为未定义数据
</code></pre>
<p>输出文字信息的同时需要引入数据，则使用格式化操作符%</p>
<pre><code class="language-python">&gt;&gt;&gt;name=&quot;Briz&quot;
&gt;&gt;&gt;print(&quot;my name is %s&quot;%name)
&gt;&gt;&gt;my name is Briz
</code></pre>
<p>if条件语句:两个数比大小</p>
<pre><code class="language-python">num1=int(input(&quot;Input a digital:&quot;))
num2=int(input(&quot;Input another digital:&quot;))
if num1==num2:
    print(&quot;euqal!&quot;)
elif num1&gt;num2:
    print(num1)
else:
    print(num2)
</code></pre>
<p>三个数比大小</p>
<pre><code class="language-python">num1=int(input(&quot;Input a digital:&quot;))
num2=int(input(&quot;Input another digital:&quot;))
num3=int(input(&quot;Input last digital:&quot;))
if num1==num2:
    print(&quot;euqal!&quot;)
elif (num1&gt;num2) and (num1&gt;num3):
    print(num1)
elif(num2&gt;num1) and (num2&gt;num3):
    print(num2)
else:
    print(num3)
</code></pre>
<p>if实例：石头剪刀布小游戏</p>
<pre><code class="language-python">import random    #引入随机库
AI=random.randint(0,2)  #随机生成0-2之间的随机数
x=int(input(&quot;Please input:scissors is 0,stone is 1,cloth is 2: &quot;))
if x&gt;=0 and x&lt;3:
    if (x==0 and AI==1)or(x==1 and AI==2)or(x==2 and AI==0):
        print(&quot;AI's input:%d,You are failed!&quot;%AI)
    elif (x==AI):
        print(&quot;AI's input:%d,You are tied!&quot;%AI)
    else:
        print(&quot;AI's input:%d,You are tied!&quot;%AI)
else:
    print(&quot;You are out of range!&quot;)
</code></pre>
<p>for循环语句 for i in range(start,stop,step)</p>
<blockquote>
<p>start--起始值  stop--终止值  step--增减值</p>
</blockquote>
<pre><code class="language-python">sum=0
for i in range(1,101,1):  #在1到101范围以1递增
    sum+=i
print(sum)   #此处应注意别将print语句写入循环
</code></pre>
<pre><code class="language-python">&gt;&gt;&gt;for i in range(5):
    print(i,end=&quot; &quot;)    #以空格分隔，不然默认会换行
0 1 2 3 4

name=&quot;Love U!&quot;
for i in name:
    print(i,end=&quot;\t&quot;)
    
a=[&quot;aa&quot;,&quot;bb&quot;,&quot;cc&quot;,&quot;dd&quot;]
for i in range(len(a)):  #len()得到元组长度的函数
    print(i,a[i])
</code></pre>
<p>break，continue和pass(占位语句无作用)</p>
<pre><code class="language-python">word=LOVE
for i in word:
    	if i==&quot;V&quot;:
            	break
            print(i)
L
O

for i in word:
    	if i==&quot;V&quot;:
            	continue
            print(i)
L
O
E
</code></pre>
<p>while 条件循环</p>
<pre><code class="language-python">&gt;&gt;&gt;num=[1,2,3,4,4,4,4,4]
&gt;&gt;&gt;while 4 in num
&gt;&gt;&gt;num.remove(4)
&gt;&gt;&gt;num
[1,2,3]
</code></pre>
<p>打印9*9乘法表</p>
<pre><code class="language-python">for i in range(1,10,1):
    for j in range(1, i + 1, 1):
        print(&quot;%d*%d=%d&quot; % (i, j, i*j),end=&quot; &quot;)
    print(&quot;&quot;)
</code></pre>
<p>字符串</p>
<pre><code class="language-python">str=&quot;This is a text&quot;
print(str[0:7])  #打印0-6个字符
This is
print(str[0:7:2])  #打印0-6个字符但每隔两个字符打印一次
Ti s
print(&quot;this\tis&quot;)
this	is
print(r&quot;this\tis&quot;)
this\tis    #字符串前加r使里面的转义失效并直接显示
print(&quot;hello &quot;+&quot;world&quot;)
hello world    #字符连接使用+
</code></pre>
<p>列表 list[]</p>
<pre><code class="language-python">&gt;&gt;&gt;#创建一个普通的列表
&gt;&gt;&gt;songs=[&quot;Green Light&quot;,&quot;Sober&quot;,&quot;Liability&quot;,&quot;Write in the dark&quot;]
&gt;&gt;&gt;print(songs)
[&quot;Green Light&quot;,&quot;Sober&quot;,&quot;Liability&quot;,&quot;Write in the dark&quot;]
&gt;&gt;&gt;songs[1]
&quot;Sober&quot;

&gt;&gt;&gt;#创建一个混合的列表
&gt;&gt;&gt;mix_lists=[&quot;1&quot;,&quot;2&quot;,&quot;test&quot;,&quot;4&quot;]

&gt;&gt;&gt;#默认函数list：把参数生成一个列表
&gt;&gt;&gt;name=&quot;Briz&quot;
&gt;&gt;&gt;list(name)
&gt;&gt;&gt;[&quot;B&quot;,&quot;r&quot;,&quot;i&quot;,&quot;z&quot;]

#若已经使用list关键字定义了一个列表，则不能再次使用list函数
#因此不建议使用list创建列表，但可以用list1等

&gt;&gt;&gt;songs=[&quot;Green Light&quot;,&quot;Sober&quot;,&quot;Liability&quot;,&quot;Write in the dark&quot;]
&gt;&gt;&gt;songs
[&quot;Green Light&quot;,&quot;Sober&quot;,&quot;Liability&quot;,&quot;Write in the dark&quot;]
&gt;&gt;&gt;songs.append(&quot;Perfect Place&quot;)
#无反馈但是append函数已经生效
&gt;&gt;&gt;songs
[&quot;Green Light&quot;,&quot;Sober&quot;,&quot;Liability&quot;,&quot;Write in the dark&quot;,&quot;Perfect Place&quot;]

a=[1,2]
b=[3,4]
a.append(b)
print(a)
[1, 2, [3, 4]]    #b列表被当成一个元素即a[2]加入a列表
#append()函数默认向列表最后添加一个元素--入栈

&gt;&gt;&gt;songs.extend([&quot;Royals&quot;,&quot;The Louvre&quot;])
&gt;&gt;&gt;songs
[&quot;Green Light&quot;,&quot;Sober&quot;,&quot;Liability&quot;,&quot;Write in the dark&quot;,&quot;Royals&quot;,&quot;The Louvre&quot;]
#extend()默认用一个新的列表拓展原列表

&gt;&gt;&gt;songs.insert(1,&quot;Supercut&quot;)
&gt;&gt;&gt;songs
[&quot;Green Light&quot;,&quot;Supercut&quot;,&quot;Sober&quot;,&quot;Liability&quot;,&quot;Write in the dark&quot;,&quot;Royals&quot;,&quot;The Louvre&quot;]
#insert()在第几项元素插入新元素

&gt;&gt;&gt;songs.remove(&quot;Sober&quot;)
&gt;&gt;&gt;songs
[&quot;Green Light&quot;,&quot;Liability&quot;,&quot;Write in the dark&quot;,&quot;Royals&quot;,&quot;The Louvre&quot;]
#remove() 删除列表的值

&gt;&gt;&gt;songs.pop()
&quot;The Louvre&quot;
#pop() 默认删除末尾最后一个元素，并且有返还值
&gt;&gt;&gt;songs.pop(5)
&quot;Royals&quot;
#指定删除某项元素
&gt;&gt;&gt;del songs(0)
&quot;Green Light&quot;
#与上面同样效果
&gt;&gt;&gt;del songs
&gt;&gt;&gt;songs
#删除整个列表
</code></pre>
<p>拼接操作符+（两边的数据类型必须一致）</p>
<pre><code class="language-python">&gt;&gt;&gt;num1=[1,2]
&gt;&gt;&gt;num2=[100,200]
&gt;&gt;&gt;num1+num2
&gt;&gt;&gt;[1,2,100,200]
</code></pre>
<p>列表的成员检查操作符 in</p>
<pre><code class="language-python">&gt;&gt;&gt;num=[1,2,True,[1,2,3,4]]   #列表1234在列表num的第四个元素
&gt;&gt;&gt;1 in num
True
&gt;&gt;&gt;3 in num
False     #3在num的第四号元素里
&gt;&gt;&gt;3 in num[3]
True

songs=[&quot;Green Light&quot;,&quot;Sober&quot;,&quot;Liability&quot;,&quot;Write in the dark&quot;]
findsong=input(&quot;Please input a song that you want to find:&quot;)
if findsong in songs:
   print(&quot;It is existed&quot;)
else:
   print(&quot;It is not existed&quot;)

songs=[&quot;Green Light&quot;,&quot;Sober&quot;,&quot;Liability&quot;,&quot;Write in the dark&quot;]
print(songs.index(&quot;Sober&quot;,0,2))
1    #查找指定范围的元素并返回相应数据的下标，且左闭右开区间
</code></pre>
<p>拷贝</p>
<pre><code class="language-python">#赋值拷贝 浅拷贝
&gt;&gt;&gt;num=[4,3,2,1]
&gt;&gt;&gt;num1=num
&gt;&gt;&gt;num1
[4,3,2,1]
#切片拷贝 深拷贝
&gt;&gt;&gt;num2=num[:]
&gt;&gt;&gt;num2
&gt;&gt;&gt;[4,3,2,1]
#升序排序
&gt;&gt;&gt;num.sort()
&gt;&gt;&gt;num
&gt;&gt;&gt;[1,2,3,4]
&gt;&gt;&gt;num1
&gt;&gt;&gt;[1,2,3,4]
&gt;&gt;&gt;num2
&gt;&gt;&gt;[4,3,2,1]   
#通过赋值拷贝的列表会随着原列表的改变而改变
#而切片拷贝则是完整拷贝且值不会随着原列表的改变而改变
</code></pre>
<p>count() 计数函数</p>
<pre><code class="language-python">&gt;&gt;&gt;num=[1,1,1,2,3]
&gt;&gt;&gt;num.count(1)
&gt;&gt;&gt;3
</code></pre>
<p>reverse() 反转函数</p>
<pre><code class="language-python">&gt;&gt;&gt;num=[1,2,3,4]
&gt;&gt;&gt;num.reserve()
&gt;&gt;&gt;num
[4,3,2,1]
</code></pre>
<p>sort()排序函数</p>
<pre><code class="language-python">a=[3,5,1,2]
a.sort()
print(a)
[1,2,3,5]
a.sort(reverse=True)
print(a)
[5,3,2,1]
</code></pre>
<p>list实例：</p>
<blockquote>
<p>---- Product list ----<br>
0  iPhone    6888<br>
1  MacPro   14800<br>
2  Mi6        2499<br>
3  NIKE       699<br>
4  Vans       499<br>
5  adidas     399</p>
<p>打印上面的products列表并写一个循环，不断询问用户想买什么，用户选择一个商品编号，就把对应的商品添加到购物车里，最终用户输入q退出时，打印购买的商品列表并计算总价。</p>
</blockquote>
<pre><code class="language-python">products=[[&quot;iPhone&quot;,6888],[&quot;MacPro&quot;,14800],[&quot;Mi6&quot;,2499],[&quot;NIKE&quot;,699],[&quot;Vans&quot;,499],[&quot;adidas&quot;,399]]
print(&quot;---- Product list ----&quot;)
for i in range(0,6):
    print(&quot;%d  %-6s  %-6d&quot;%(i,products[i][0],products[i][1]))
shop=[]
sum=0
i=1
while i!=0:
    p = input(&quot;Please input product's number to buy it:&quot;)
    if p==&quot;q&quot;:
        x=input(&quot;Are you sure to settle the product? y/n:&quot;)
        if x==&quot;y&quot;:
            print(&quot;---- Your shopping cart ----&quot;)
            for n in shop:
                print(&quot;%s  %s&quot; % (products[n][0], products[n][1]))
            print(&quot;You need to pay:%d&quot; % sum)
            break
        else:
            continue
    elif p&gt;&quot;0&quot; and p&lt;&quot;6&quot;:
        p=int(p)
        shop.append(p)
        sum += products[p][1]
        print(&quot;Add to Cart successful!&quot;)
    else:
        print(&quot;Please input the currect product's number!&quot;)
</code></pre>
<p>元组 tuple()</p>
<pre><code class="language-python">#元组也是一种列表但是为只读列表
&gt;&gt;&gt;tuple1=(1,2,3,4)
&gt;&gt;&gt;tuple1
(1,2,3,4)
&gt;&gt;&gt;tuple2=(1)
&gt;&gt;&gt;tuple2
1
&gt;&gt;&gt;tuple3=1,
&gt;&gt;&gt;tuple3
(1,)
#, 逗号是元组的标识符 创建只有一个元素的元组时末尾应加上,逗号
#创建一个空元组
&gt;&gt;&gt;tuple4=()
&gt;&gt;&gt;tuple4
()

tup1=(1,2,3)
tup2=(&quot;a&quot;,&quot;b&quot;)
tup=tup1+tup2
print(tup)
(1, 2, 3, 'a', 'b')
#虽不可修改但可以连接
</code></pre>
<p>字典 dict</p>
<pre><code class="language-python">&gt;&gt;&gt;dict1={1:11,ab:&quot;test&quot;}
&gt;&gt;&gt;dict1
{1:11,ab:&quot;text&quot;}
&gt;&gt;&gt;# 访问字典元素的值与列表和元组相同，但列表和元组通过下标索引来取值
&gt;&gt;&gt;#字典就是通过key键来取值
&gt;&gt;&gt;dict1[ab]
&quot;text&quot;
&gt;&gt;&gt;#快速定义字典
&gt;&gt;&gt;name=[&quot;Briz&quot;,&quot;Jixy&quot;]
&gt;&gt;&gt;sign=[&quot;1&quot;,&quot;2&quot;]
&gt;&gt;&gt;dict2=dict(zip(name,sign))
&gt;&gt;&gt;dict2
{&quot;Briz&quot;:&quot;1&quot;,&quot;Jixy&quot;:&quot;2&quot;}

info={&quot;name&quot;:&quot;Briz&quot;,&quot;age&quot;:20}
#print(info[&quot;gender&quot;])    #直接访问不存在的键会报错
print(info.get(&quot;gender&quot;))    #使用get方法若没有找到对应的键默认返回 None
print(info.get(&quot;gender&quot;,&quot;male&quot;))    #若没找到可以设定默认值

None
male

info={&quot;name&quot;:&quot;Briz&quot;,&quot;age&quot;:20}
print(info.keys())    #打印全部键(列表形式)
print(info.values())    #打印全部的键对应的值(列表形式)
print(info.items())    #打印全部的键值(列表形式，且每个键值是一个元组)
info[&quot;id&quot;]=12    #新增键值
info[&quot;age&quot;]=18    #修改键值
del info[&quot;name&quot;]    #删除键值
print(info)

dict_keys(['name', 'age'])
dict_values(['Briz', 20])
dict_items([('name', 'Briz'), ('age', 20)])
{'age': 18, 'id': 12}

info.clear()    #清空字典的值但保留空字典
del info    #删除info字典

#使用枚举函数
a=[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]
for i,x in enumerate(a):
    print(i+1,x)
1 a
2 b
3 c
</code></pre>
<p>集合 set</p>
<pre><code class="language-python">&gt;&gt;&gt;set1={1,2,2,2,3,3,3,3,3}    #集合里的元素是不重复的
&gt;&gt;&gt;set1
{1,2,3}    
</code></pre>
<p>lambda函数</p>
<pre><code class="language-python">&gt;&gt;&gt;lamdba a:a+8   ##定义一个函数
&gt;&gt;&gt;d=lamdba a:a+8
&gt;&gt;&gt;&gt;d(1)   ##调用函数
9
</code></pre>
<p>类和对象</p>
<pre><code class="language-python">class Turtle:   ##创建类Turtle
	def run(self):  ##用ABC替代self
		print(&quot;I run slowly&quot;)
        	print(&quot;my name is %s&quot;%self.name)
	def sleep(self):
		print(&quot;I can sleep all day!&quot;)
        def __inti__(self):    ##__init__是一个专门给对象添加属性的方法，初始化属性
            self.name=&quot;托尼&quot;
        def __del__(self):  ##当一个对象不再使用时进行销毁
            print(&quot;Had deleted!&quot;)
            
ABC=Turtle()         ##创建一个对象


&gt;&gt;&gt; ABC.sleep()        ##调用Turtle类
I can sleep all day!
&gt;&gt;&gt; ABC.run()
I run slowly
&gt;&gt;&gt;ABC.name=&quot;Tony&quot;
&gt;&gt;&gt;ABC.run()
I run slowly
my name is Tony
</code></pre>
<p><code>EG</code>:</p>
<pre><code class="language-python">class Student:
    def __init__(self,name,age,grade):
        self.name=name
        self.age=age
        self.grade=grade
    def get_name(self):
        return self.name
    def get_age(self):
        return self.age
    def get_grade(self):
        return max(self.grade)

stu1=Student(&quot;Briz&quot;,20,[100,95,98])
print(&quot;Name:%s&quot;%(stu1.get_name()))
print(&quot;Age:%d&quot;%(stu1.get_age()))
print(&quot;Max grade:%s&quot;%(stu1.get_grade()))

</code></pre>
<p>继承，重写与拓展</p>
<pre><code class="language-python">class Animal:
    def eat(self):
        print(&quot;I can eat&quot;)
    def sleep(self):
        print(&quot;I can sleep&quot;)
class Dog(Animal):  ##子类后面跟父类则继承父类属性
    def bark(self):
        print(&quot;I can bark&quot;)

        
class Animal:
    def eat(self):
        print(&quot;I can eat&quot;)
    def sleep(self):
        print(&quot;I can sleep&quot;)
class Cat(Animal):  
    def eat(self):
        print(&quot;I only eat fish&quot;)     ##子类重写父类的eat属性其他属性不变
    def sleep(self):
        super().sleep()    ##对父类方法进行拓展，调用父类sleep属性的同时修改子类的特殊需求
        print(&quot;I sleep gently&quot;)
</code></pre>
<p>文件操作</p>
<pre><code class="language-python">f=open(&quot;text.py&quot;,&quot;w&quot;)    #以只写的模式打开文件，若不存在则新建该文件
f.write(&quot;This is a text!&quot;)    #写入内容
f.close()    #关闭文件
#以上代码会生成一个text.txt的文本文件，并写入“This is a text!”

f=open(&quot;text.txt&quot;,&quot;r&quot;)
content=f.read(10)    #使用读模式读取10个字符
print(content)
f.close()
This is a 

f=open(&quot;text.txt&quot;,&quot;r&quot;)
content=f.readlines()    #一次读取全部文件为列表，f.readline()为一次打印一行
for t in content:
    print(&quot;%s&quot;%t)
f.close()

This is a text!

This is a text!

This is a text!

This is a text!

This is a text!

import os    #引入os模块
os.rename(&quot;text.txt&quot;,&quot;1.txt&quot;)    #将text文本文件改名为1
os.remove(&quot;1.txt&quot;)    #删除1文本文件

</code></pre>
<blockquote>
<p><code>访问模式说明</code></p>
<p>r 以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。</p>
<p>w 打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文 件。</p>
<p>a 打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说， 新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</p>
<p>rb 以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。</p>
<p>wb 以二进制格式打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存 在，创建新文件。</p>
<p>ab 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结 尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进 行写入。</p>
<p>r+ 打开一个文件用于读写。文件指针将会放在文件的开头。</p>
<p>w+ 打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文 件。</p>
<p>a+ 打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时 会是追加模式。如果该文件不存在，创建新文件用于读写。</p>
<p>rb+ 以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。</p>
<p>wb+ 以二进制格式打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存 在，创建新文件。</p>
<p>ab+ 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结 尾。如果该文件不存在，创建新文件用于读写。</p>
</blockquote>
<p>错误与异常</p>
<pre><code class="language-python">try:
    print(name)
except Exception as result:    #异常类型捕获
    print(&quot;error!&quot;)
    print(result)
    
error!
name 'num' is not defined

try:
    try:
        print(num)
    finally:    #无论try内的语句有没有执行，finally内语句都会执行
        print(&quot;123&quot;)
except Exception as result:
    print(result)
    
123
name 'num' is not defined
</code></pre>
<p>实例：</p>
<blockquote>
<ol>
<li>应用文件操作的相关知识，通过Python新建一个文件gushi.txt，选择一首古诗写入文件中</li>
<li>另外写一个函数，读取指定文件gushi.txt，将内容复制到copy.txt中，并在控制台输出“复制完<br>
毕”。</li>
<li>提示：分别定义两个函数，完成读文件和写文件的操作，尽可能完善代码，添加异常处理。</li>
</ol>
</blockquote>
<pre><code class="language-python">f=open(&quot;Liability.txt&quot;,&quot;w&quot;,encoding=&quot;utf-8&quot;)
f.write(&quot;春眠不觉晓\n处处闻啼鸟&quot;)
f.close()
def Read(file_name1):
    try:
        f=open(file_name1,&quot;r&quot;,encoding=&quot;utf-8&quot;)
        try:
            while True:
                content=f.read()
                if content==0:
                    print(&quot;This document is not exisited!&quot;)
                    break
                print(&quot;Content has been copied!&quot;)
                return content
        finally:
            f.close()
    except Exception as result:
        print(result)
def Copy(content,file_name2):
    f = open(file_name2,&quot;w&quot;,encoding=&quot;utf-8&quot;)
    f.write(content)
    print(&quot;Copy successully!&quot;)
    f.close()
file_name1 = input(&quot;Please input file's name:&quot;)
Content=Read(file_name1)
file_name2 = input(&quot;Please input file's name you want to copy:&quot;)
Copy(Content,file_name2)
</code></pre>
<p>计算出每行和，每列和，每行最大值，每行最小值和累计和</p>
<pre><code class="language-python">import numpy

myarr=numpy.arange(12).reshape(3,4)
print(myarr)
print(myarr.sum(axis=0))  #每行和
print(myarr.sum(axis=1))  #每列和
print(myarr.max(axis=0))  #每行最大值
print(myarr.max(axis=1))  #每列最大值
print(myarr.cumsum(axis=0))  #每行累计和
</code></pre>
<p>降低数组的维度</p>
<pre><code class="language-python">import numpy
arr=numpy.int32(100*numpy.random.rand(3,4))
arr1=arr.ravel()
print(arr)
print(arr1)

[[55 67 81 12]
 [80  2 84 72]
 [55 72 69 59]]
[55 67 81 12 80  2 84 72 55 72 69 59]
</code></pre>
<p>转置数组</p>
<pre><code class="language-python">arr.shape=(6,2)
print(arr)
arr1=arr.transpose()
print(arr1)

[[51 42]
 [57 19]
 [66 26]
 [58 23]
 [39 95]
 [32  9]]
[[51 57 66 58 39 32]
 [42 19 26 23 95  9]]
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[爬虫初体验]]></title>
        <id>https://briz-519.github.io/post/pa-chong-chu-ti-yan/</id>
        <link href="https://briz-519.github.io/post/pa-chong-chu-ti-yan/">
        </link>
        <updated>2020-08-11T10:07:47.000Z</updated>
        <content type="html"><![CDATA[<h2 id="准备工作">准备工作</h2>
<p>首行填写防止中文乱码：#coding=utf-8</p>
<p>可加入main函数用于测试程序：</p>
<pre><code class="language-python">if __name__ ==&quot;__main__&quot;    #等同于C语言等其他语言的主函数
</code></pre>
<p>引入模块：</p>
<blockquote>
<p>本质为.py文件，用于提高代码的可维护性，可使用import来导入模块</p>
</blockquote>
<p>import sys 系统函数库</p>
<p>import bs4 网页解析获取数据</p>
<p>import sqlite3 进行SQLite数据库操作</p>
<p>import urllib.request,urllib.error 制定URL获取网页数据</p>
<p>import xlwt 进行EXCEL操作</p>
<p>import re 正则表达式进行文字匹配</p>
<blockquote>
<p><code>模块 module</code>：一般情况下，是一个以.py为后缀的文件。 module 可看作一个工具类，可共用或者隐藏代码细节，将相关代码放置在一个module以便让代码更 好用、易懂，让coder重点放在高层逻辑上。 module能定义函数、类、变量，也能包含可执行的代码。module来源有3种： ①Python内置的模块（标准库）； ②第三方模块； ③自定义模块。</p>
<p><code>包 package</code>： 为避免模块名冲突，Python引入了按目录组织模块的方法，称之为 包（package）。包 是含有Python模块的文件夹。</p>
</blockquote>
<h3 id="urllib模块">urllib模块</h3>
<p>是最基本的python内置的一个http请求库，不需要额外的安装。只需要关注请求的链接，参数，提供了强大的解析功能</p>
<p><code>urllb.request 请求模块</code></p>
<p><code>urllib.error 异常处理模块</code></p>
<p><code>urllib.parse 解析模块</code></p>
<p>简单的一个get请求</p>
<pre><code class="language-python">import urllib.request     #引入库
reponse = urllib.request.urlopen('http://www.baidu.com') 
print(reponse.read().decode('utf-8'))    #decode(&quot;utf-8&quot;)将数据解码为utf-8格式数据
</code></pre>
<p>简单的一个post请求</p>
<pre><code class="language-python">import urllib.parse
import urllib.request
data = bytes(urllib.parse.urlencode({'hello':'world'}),encoding='utf-8')
reponse = urllib.request.urlopen('http://httpbin.org/post',data=data)
print(reponse.read().decode('utf-8'))
</code></pre>
<p>超时处理</p>
<pre><code class="language-python">import urllib.request
try:
    response=urllib.request.urlopen(&quot;http://httpbin.org/get&quot;,timeout=0.01)    #设置超时时间防止无限加载
    print(response.read().decode(&quot;utf-8&quot;))
except urllib.error.URLError as e:
    print(&quot;Time out!&quot;)
</code></pre>
<pre><code class="language-python">import urllib.request
response = urllib.request.urlopen('http://www.baidu.com')
print(response.status) # 状态码 判断请求是否成功
print(response.getheaders()) # 响应头 得到的一个元组组成的列表
print(response.getheader('Server')) #得到特定的响应头
print(response.read().decode('utf-8')) #获取响应体的内容，字节流的数据，需要转成utf-8
格式
</code></pre>
<p>由于通过Pycharm获取网页信息会被网站的反爬虫识别，因此可以通过修改hearers里的user-agent来伪装成浏览器发送请求</p>
<pre><code class="language-python">from urllib import request,parse
url=&quot;http://httpbin.org/post&quot;
data=bytes(urllib.parse.urlencode({&quot;name&quot;:&quot;Briz&quot;}),encoding=&quot;utf-8&quot;)
headers={&quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.116 Safari/537.36 Edg/83.0.478.58&quot;}    
req=urllib.request.Request(url=url,headers=headers,data=data,method=&quot;POST&quot;)
response=urllib.request.urlopen(req)
print(response.read().decode(&quot;utf-8&quot;))

</code></pre>
<blockquote>
<p>获取user-agent方法：</p>
</blockquote>
<blockquote>
<h6 id="urlopen方法中的url参数可以是字符串也可以是一个request对象">urlopen()方法中的url参数可以是字符串，也可以是一个Request对象</h6>
</blockquote>
<pre><code class="language-python">#url可以是字符串
import urllib.request
resp = urllib.request.urlopen('http://www.baidu.com')
print(resp.read().decode('utf-8'))  # read()获取响应体的内容，内容是bytes字节流，需要转换成字符串

##url可以也是Request对象
import urllib.request
request = urllib.request.Request('http://httpbin.org')
response = urllib.request.urlopen(request)
print(response.read().decode('utf-8'))
</code></pre>
<h3 id="beautifulsoup模块">BeautifulSoup模块</h3>
<p>Beautiful Soup 是一个HTML/XML的解析器，主要的功能是如何解析和提取 HTML/XML 数据。</p>
<blockquote>
<p>BeautifulSoup支持Python标准库中的HTML解析器,还支持一些第三方的解析器，如果我们不安装它， 则 Python 会使用 Python默认的解析器，lxml 解析器更加强大，速度更快，推荐使用lxml 解析器。 Beautiful Soup自动将输入文档转换为Unicode编码，输出文档转换为utf-8编码。你不需要考虑编码方 式，除非文档没有指定一个编码方式，这时，Beautiful Soup就不能自动识别编码方式了。然后，你仅仅需要说明一下原始编码方式就可以了。</p>
</blockquote>
<p>创建BeautifulSoup4对象</p>
<pre><code class="language-python">from bs4 import BeautifulSoup
file = open('./aa.html', 'rb')
html = file.read()
bs = BeautifulSoup(html,&quot;html.parser&quot;) # 缩进格式
</code></pre>
<h4 id="beautifulsoup4四大对象种类">BeautifulSoup4四大对象种类</h4>
<p>BeautifulSoup4将复杂HTML文档转换成一个复杂的树形结构,每个节点都是Python对象,所有对象可以 归纳为4种:</p>
<p><code>Tag</code></p>
<p><code>NavigableString</code></p>
<p><code>BeautifulSoup</code></p>
<p><code>Comment</code></p>
<h5 id="tag">Tag</h5>
<p>Tag通俗点讲就是HTML中的一个个标签，例如：</p>
<pre><code class="language-python">from bs4 import BeautifulSoup
file = open('./aa.html', 'rb')
html = file.read()
bs = BeautifulSoup(html,&quot;html.parser&quot;)

print(bs.title)# 获取title标签的所有内容

print(bs.head)# 获取head标签的所有内容

print(bs.a)# 获取第一个a标签的所有内容

print(type(bs.a))# 类型
</code></pre>
<blockquote>
<p>我们可以利用 soup 加标签名轻松地获取这些标签的内容，这些对象的类型是bs4.element.Tag。但是，它查找的是在所有内容中的<code>第一个</code>符合要求的标签(不包括被注释的)。</p>
</blockquote>
<p>对于 Tag，它有两个重要的属性，是 name 和 attrs：</p>
<pre><code class="language-python">from bs4 import BeautifulSoup
file = open('./aa.html', 'rb')
html = file.read()
bs = BeautifulSoup(html,&quot;html.parser&quot;)

print(bs.name)# [document] #bs 对象本身比较特殊，它的 name 即为 [document]

print(bs.head.name)# head #对于其他内部标签，输出的值便为标签本身的名称

print(bs.a.attrs)# 把 a 标签的所有属性打印输出了出来，得到的类型是一个字典。

print(bs.a['class']) # 等价 bs.a.get('class')

bs.a['class'] = &quot;newClass&quot;# 可以对这些属性和内容等等进行修改

del bs.a['class']# 对这个属性进行删除

</code></pre>
<h5 id="navigablestring">NavigableString</h5>
<pre><code class="language-python">from bs4 import BeautifulSoup
file = open('./aa.html', 'rb')
html = file.read()
bs = BeautifulSoup(html,&quot;html.parser&quot;)
print(bs.title.string)    #获取标签内部的文字
print(type(bs.title.string))
</code></pre>
<h5 id="beautifulsoup">BeautifulSoup</h5>
<p>BeautifulSoup对象表示的是一个文档的内容。大部分时候，可以把它当作 Tag 对象，是一个特殊的 Tag，我们可以分别获取它的类型，名称，以及属性</p>
<pre><code class="language-python">from bs4 import BeautifulSoup
file = open('./aa.html', 'rb')
html = file.read()
bs = BeautifulSoup(html,&quot;html.parser&quot;)
print(type(bs.name))
print(bs.name)
print(bs.attrs)
{'class': ['mnav'], 'href': 'http://news.baidu.com', 'name': 'tj_trnews'}
</code></pre>
<h5 id="comment">Comment</h5>
<p>Comment 对象是一个特殊类型的 NavigableString 对象，其输出的内容不包括注释符号</p>
<pre><code class="language-python">from bs4 import BeautifulSoup
file = open('./aa.html', 'rb')
html = file.read()
bs = BeautifulSoup(html,&quot;html.parser&quot;)
print(bs.a)
# 此时不能出现空格和换行符，a标签如下：
# &lt;a class=&quot;mnav&quot; href=&quot;http://news.baidu.com&quot; name=&quot;tj_trnews&quot;&gt;&lt;!--新闻--&gt;&lt;/a&gt;
print(bs.a.string) # 新闻
print(type(bs.a.string)) # &lt;class 'bs4.element.Comment'&gt;
</code></pre>
<h4 id="遍历文档树">遍历文档树</h4>
<p>5.1 .contents：获取Tag的所有子节点，返回一个list</p>
<pre><code class="language-python"># tag的.content 属性可以将tag的子节点以列表的方式输出
print(bs.head.contents)
# 用列表索引来获取它的某一个元素
print(bs.head.contents[1])
</code></pre>
<p>5.2 .children：获取Tag的所有子节点，返回一个生成器</p>
<pre><code class="language-python">for child in bs.body.children:
print(child)
</code></pre>
<blockquote>
<p>5.3、.descendants：获取Tag的所有子孙节点</p>
<p>5.4、.strings：如果Tag包含多个字符串，即在子孙节点中有内容，可以用此获取，而后进行遍历</p>
<p>5.5、.stripped_strings：与strings用法一致，只不过可以去除掉那些多余的空白内容</p>
<p>5.6、.parent：获取Tag的父节点</p>
<p>5.7、.parents：递归得到父辈元素的所有节点，返回一个生成器</p>
<p>5.8、.previous_sibling：获取当前Tag的上一个节点，属性通常是字符串或空白，真实结果是当前标签 与上一个标签之间的顿号和换行符</p>
<p>5.9、.next_sibling：获取当前Tag的下一个节点，属性通常是字符串或空白，真是结果是当前标签与下 一个标签之间的顿号与换行符</p>
<p>5.10、.previous_siblings：获取当前Tag的上面所有的兄弟节点，返回一个生成器</p>
<p>5.11、.next_siblings：获取当前Tag的下面所有的兄弟节点，返回一个生成器</p>
<p>5.12、.previous_element：获取解析过程中上一个被解析的对象(字符串或tag)，可能与 previous_sibling相同，但通常是不一样的</p>
<p>5.13、.next_element：获取解析过程中下一个被解析的对象(字符串或tag)，可能与next_sibling相同， 但通常是不一样的</p>
<p>5.14、.previous_elements：返回一个生成器，可以向前访问文档的解析内容</p>
<p>5.15、.next_elements：返回一个生成器，可以向后访问文档的解析内容</p>
<p>5.16、.has_attr：判断Tag是否包含属性</p>
</blockquote>
<h4 id="搜索文档树">搜索文档树</h4>
<p>find_all(name, attrs, recursive, text, **kwargs)</p>
<h5 id="name参数">name参数：</h5>
<p>字符串过滤：会查找与字符串完全匹配的内容</p>
<pre><code class="language-python">a_list = bs.find_all(&quot;a&quot;)
print(a_list)
</code></pre>
<p>正则表达式过滤：如果传入的是正则表达式，那么BeautifulSoup4会通过search()来匹配内容</p>
<pre><code class="language-python">from bs4 import BeautifulSoup
import re
file = open('./aa.html', 'rb')
html = file.read()
bs = BeautifulSoup(html,&quot;html.parser&quot;)
t_list = bs.find_all(re.compile(&quot;a&quot;))    #列表输出所有带a的标签
for item in t_list:
print(item)
</code></pre>
<h5 id="kwargs参数">kwargs参数：</h5>
<pre><code class="language-python">from bs4 import BeautifulSoup
import re
file = open('./aa.html', 'rb')
html = file.read()
bs = BeautifulSoup(html,&quot;html.parser&quot;)
# 查询id=head的Tag
t_list = bs.find_all(id=&quot;head&quot;)
print(t_list)
# 查询href属性包含news.baidu.com的Tag
t_list = bs.find_all(href=re.compile(&quot;http://news.baidu.com&quot;))
print(t_list)
# 查询所有包含class的Tag(注意：class在Python中属于关键字，所以加_以示区别)
t_list = bs.find_all(class_=True)
for item in t_list:
print(item)
</code></pre>
<h5 id="text参数">text参数：</h5>
<p>通过text参数可以搜索文档中的字符串内容，与name参数的可选值一样，text参数接受 字符串，正则 表达式，列表</p>
<pre><code class="language-python">from bs4 import BeautifulSoup
import re
file = open('./aa.html', 'rb')
html = file.read()
bs = BeautifulSoup(html, &quot;html.parser&quot;)
t_list = bs.find_all(attrs={&quot;data-foo&quot;: &quot;value&quot;})
for item in t_list:
print(item)
t_list = bs.find_all(text=&quot;hao123&quot;)
for item in t_list:
print(item)
t_list = bs.find_all(text=[&quot;hao123&quot;, &quot;地图&quot;, &quot;贴吧&quot;])
for item in t_list:
print(item)
t_list = bs.find_all(text=re.compile(&quot;\d&quot;))    #带有数字的内容
for item in t_list:
print(item)
</code></pre>
<p>当我们搜索text中的一些特殊属性时，同样也可以传入一个方法来达到我们的目的：</p>
<pre><code class="language-python">def length_is_two(text):
return text and len(text) == 2
t_list = bs.find_all(text=length_is_two)
for item in t_list:
print(item)
</code></pre>
<h5 id="limit参数">limit参数：</h5>
<p>可以传入一个limit参数来限制返回的数量，当搜索出的数据量为5，而设置了limit=2时，此时只会返回 前2个数据</p>
<pre><code class="language-python">from bs4 import BeautifulSoup
import re
file = open('./aa.html', 'rb')
html = file.read()
bs = BeautifulSoup(html, &quot;html.parser&quot;)
t_list = bs.find_all(&quot;a&quot;,limit=2)
for item in t_list:
print(item)
</code></pre>
<p>find_all除了上面一些常规的写法，还可以对其进行一些简写：</p>
<pre><code class="language-python"># 两者是相等的
# t_list = bs.find_all(&quot;a&quot;) =&gt; t_list = bs(&quot;a&quot;)
t_list = bs(&quot;a&quot;) # 两者是相等的
# t_list = bs.a.find_all(text=&quot;新闻&quot;) =&gt; t_list = bs.a(text=&quot;新闻&quot;)
t_list = bs.a(text=&quot;新闻&quot;)
</code></pre>
<p>find()</p>
<p>find()将返回符合条件的第一个Tag，有时我们只需要或一个Tag时，我们就可以用到find()方法了。当然 了，也可以使用find_all()方法，传入一个limit=1，然后再取出第一个值也是可以的，不过未免繁琐。</p>
<pre><code class="language-python">from bs4 import BeautifulSoup
import re
file = open('./aa.html', 'rb')
html = file.read()
bs = BeautifulSoup(html, &quot;html.parser&quot;)
# 返回只有一个结果的列表
t_list = bs.find_all(&quot;title&quot;,limit=1)
print(t_list)
# 返回唯一值
t = bs.find(&quot;title&quot;)
print(t)
# 如果没有找到，则返回None
t = bs.find(&quot;abc&quot;) print(t)
#从结果可以看出find_all，尽管传入了limit=1，但是返回值仍然为一个列表，当我们只需要取一个值时，远不如find方法方便。但是如果未搜索到值时，将返回一个None
</code></pre>
<h4 id="css选择器">CSS选择器</h4>
<p>BeautifulSoup支持发部分的CSS选择器，在Tag获取BeautifulSoup对象的.select()方法中传入字符串参 数，即可使用CSS选择器的语法找到Tag:</p>
<p>7.1、通过标签名查找</p>
<pre><code class="language-python">print(bs.select('title'))
print(bs.select('a'))
</code></pre>
<p>7.2、通过类名查找</p>
<p>print(bs.select('.mnav'))    #.对应class</p>
<p>7.3、通过id查找</p>
<p>print(bs.select('#u1'))    ##对应id</p>
<p>7.4、组合查找</p>
<p>print(bs.select('div .bri'))    #div标签内id为bri</p>
<p>7.5、属性查找</p>
<p>print(bs.select('a[class=&quot;bri&quot;]'))</p>
<p>print(bs.select('a[href=&quot;http://tieba.baidu.com&quot;]'))</p>
<p>7.6、直接子标签查找</p>
<p>t_list = bs.select(&quot;head &gt; title&quot;)</p>
<p>print(t_list)</p>
<p>7.7、兄弟节点标签查找</p>
<p>t_list = bs.select(&quot;.mnav ~ .bri&quot;)</p>
<p>print(t_list)</p>
<p>7.8、获取内容</p>
<p>t_list = bs.select(&quot;title&quot;)</p>
<p>print(bs.select('title')[0].get_text())    #获取title标签内的内容</p>
<h3 id="re模块">re模块</h3>
<h4 id="正则表达式常用操作符">正则表达式常用操作符</h4>
<table>
<thead>
<tr>
<th>操作符</th>
<th>说明</th>
<th>实例</th>
</tr>
</thead>
<tbody>
<tr>
<td>.</td>
<td>表示任何单个字符</td>
<td></td>
</tr>
<tr>
<td>[ ]</td>
<td>字符集，对单个字符给予取值范围</td>
<td>[abc]表示a,b,c，[a-z]表示a到z单个字符</td>
</tr>
<tr>
<td>[^ ]</td>
<td>非字符集，对单个字符给出取值范围</td>
<td>[^abc]表示非a或b或c的单个字符</td>
</tr>
<tr>
<td>*</td>
<td>前一个字符<code>0</code>次或无限次扩展</td>
<td>abc*表示ab,abc,abcc,abccc等</td>
</tr>
<tr>
<td>+</td>
<td>前一个字符<code>1</code>次或无限次扩展</td>
<td>abc+表示abc,abcc,abccc等</td>
</tr>
<tr>
<td>？</td>
<td>前一个字符0次或1次扩展</td>
<td>abc?表示ab,abc</td>
</tr>
<tr>
<td>|</td>
<td>左右表达式任意一个</td>
<td>abc|def表示abc,def</td>
</tr>
<tr>
<td>{m}</td>
<td>扩展前一个字符m次</td>
<td>ab{2}c表示abbc</td>
</tr>
<tr>
<td>{m,n}</td>
<td>扩展前一个字符m至n次（含n）</td>
<td>ab{1,3}c表示abc,abbc,abbbc</td>
</tr>
<tr>
<td>^</td>
<td>匹配字符串开头</td>
<td>^abc表示abc且在一个字符串的开头</td>
</tr>
<tr>
<td>$</td>
<td>匹配字符串结尾</td>
<td>abc$表示abc且在一个字符串的结尾</td>
</tr>
<tr>
<td>( )</td>
<td>分组标记，内部可使用|操作符</td>
<td>(abc)表示abc ,(abc|def)表示abc，def</td>
</tr>
<tr>
<td>\d</td>
<td>数字，等价于[0-9]</td>
<td></td>
</tr>
<tr>
<td>\w</td>
<td>单词字符，等价于[A-Z]/[a-z]/[0-9]/_</td>
<td>网站注册用户名(只能使用大小写字母数字和下划线 )</td>
</tr>
</tbody>
</table>
<blockquote>
<p>“?” ：0次或1次，match,search 不会出现none，会出现’ ‘ （因为0次也是符合的） 0次或1次不是指[xxx]这个集合，而是其中的任何的一个字符</p>
<pre><code class="language-python">pat = re.compile( [abc]? )
pat.match( defabc ).group() #0次
pat.match( abcdefabc ).group()
&gt;&gt;&gt; a
pat.search( defabc ).group() #0次
pat.findall( defabc ) #0次和1次
&gt;&gt;&gt; [ , , , a , b , c , ]
</code></pre>
<p>“数量词?” ：<code>非贪婪模式</code>：只匹配最少的（尽可能少）；默认贪婪模式：匹配最多的（尽可能多）</p>
<pre><code class="language-python">pat = re.compile( [abc]+ ) #贪婪模式
&gt;&gt;&gt; pat.match( abcdefabcabc ).group() #匹配尽可能多的：abc
&gt;&gt;&gt; abc
&gt;&gt;&gt; pat.match( bbabcdefabcabc ).group()
&gt;&gt;&gt; bbabc
&gt;&gt;&gt; pat.search( dbbabcdefabcabc ).group()
&gt;&gt;&gt; bbabc
&gt;&gt;&gt; pat.findall( abcdefabcabc )
&gt;&gt;&gt; [ abc , abcabc ]
&gt;&gt;&gt; pat = re.compile( [abc]+? ) #非贪婪模式：+?
&gt;&gt;&gt; pat.match( abcdefabcabc ).group() #匹配尽可能少的：a、b、c
&gt;&gt;&gt; a
&gt;&gt;&gt; pat.search( dbbabcdefabcabc ).group()
&gt;&gt;&gt; b
&gt;&gt;&gt; pat.findall( abcdefabcabc )
&gt;&gt;&gt; [ a , b , c , a , b , c , a , b , c ]
</code></pre>
</blockquote>
<h4 id="re库主要功能函数">Re库主要功能函数</h4>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>re.search()</td>
<td>在一个字符串中国搜索匹配正则表达式的第一个位置，<code>返回match对象</code></td>
</tr>
<tr>
<td>re.match()</td>
<td>从一个字符串的开始位置起匹配正则表达式，<code>返回match对象</code></td>
</tr>
<tr>
<td>re.findall()</td>
<td>搜索字符串，以列表类型返回全部能匹配的子串</td>
</tr>
<tr>
<td>re.split()</td>
<td>将一个字符串按照正则表达式匹配结果进行分隔，返回列表类型</td>
</tr>
<tr>
<td>re.finditer()</td>
<td>搜索字符串，返回一个匹配结果的迭代类型，<code>每个迭代对象是match对象</code></td>
</tr>
<tr>
<td>re.sub()</td>
<td>在一个字符串中替换所有匹配正则表达式的子串，返回替换后的字符串</td>
</tr>
</tbody>
</table>
<blockquote>
<p>正则表达式可以包含一些可选标志修饰符来控制匹配的模式。修饰符被指定为一个可选的标志。 多个标志可以通过按位 OR(|) 它们来指定。如 re.I | re.M 被设置成 I 和 M 标志：</p>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>re.I</td>
<td>使匹配对大小写不敏感</td>
</tr>
<tr>
<td>re.L</td>
<td>做本地化识别（locale-aware）匹配</td>
</tr>
<tr>
<td>re.M</td>
<td>多行匹配，影响 ^ 和 $</td>
</tr>
<tr>
<td>re.S</td>
<td>使 . 匹配包括换行在内的所有字符</td>
</tr>
<tr>
<td>re.U</td>
<td>根据Unicode字符集解析字符。这个标志影响 \w, \W, \b, \B.</td>
</tr>
<tr>
<td>re.X</td>
<td>该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解。</td>
</tr>
</tbody>
</table>
</blockquote>
<h5 id="函数具体用法">函数具体用法</h5>
<h6 id="compilepattern创建模式对象">compile(pattern)：创建模式对象</h6>
<pre><code class="language-python">import re
pat=re.compile(&quot;A&quot;)
#m=pat.search(&quot;CBA&quot;)
m=pat.search(&quot;ABC&quot;)
#等价于 re.search( A , CBA )
print(m)
#&lt;re.Match object; span=(2, 3), match='A'&gt; 表示匹配到了
m=pat.search(&quot;CBD&quot;)
print(m) #None 表示没匹配到
</code></pre>
<h6 id="searchpatternstring在字符串中寻找模式">search(pattern,string)：在字符串中寻找模式</h6>
<pre><code class="language-python">import re
m = re.search(&quot;asd&quot; , &quot;ASDasd&quot; )
print(m)
# &lt;_sre.SRE_Match object at 0xb72cd6e8&gt; #匹配到了，返回MatchObject（True）
m = re.search(&quot;asd&quot; , &quot;ASDASD&quot; )
print(m)     #表示没匹配到返回None(False)
</code></pre>
<h6 id="matchpatternstring在字符串开始处匹配模式">match(pattern,string)：在字符串开始处匹配模式</h6>
<pre><code class="language-python"># 等价于
pat=re.compile( &quot;a&quot; )
print(pat.match( &quot;Aasd&quot; ))
#输出None
print(pat.match(&quot;aASD&quot; ))
#输出 &lt;_sre.SRE_Match object at 0xb72cd6e8&gt;
# 上面的函数返回都可以在if条件语句中进行判断：
if pat.search(&quot;asd&quot;):
print (&quot;OK&quot;) #OK #找到返回
if re.search(&quot;a&quot;,&quot;ASD&quot; ):
print (&quot;OK&quot;) #没有找到
</code></pre>
<h6 id="splitpatternstring根据模式分割字符串返回列表">split(pattern,string)：根据模式分割字符串,返回列表</h6>
<pre><code class="language-python">re.split( , , a,s,d,asd )
[ a , s , d , asd ] #返回列表
pat = re.compile( , )
pat.split( a,s,d,asd )
[ a , s , d , asd ] #返回列表
re.split( [, ]+ , a , s ,d ,,,,,asd ) #正则匹配：[, ]+
[ a , s , d , asd ]
re.split( [, ]+ , a , s ,d ,,,,,asd ,maxsplit=2) # maxsplit 最多分割次数
[ a , s , d ,,,,,asd ]
pat = re.compile( [, ]+ ) #正则匹配：[, ]+
pat.split( a , s ,d ,,,,,asd ,maxsplit=2) # maxsplit 最多分割次数
[ a , s , d ,,,,,asd ]
</code></pre>
<h6 id="findallpatternstring列表形式返回匹配项">findall(pattern,string)：列表形式返回匹配项</h6>
<pre><code class="language-python">import re
print(re.findall( &quot;a&quot; , &quot;ASDaDFGAa&quot; ))
#[ a , a ] #列表形式返回匹配到的字符串
pat = re.compile( &quot;a&quot; )
print(pat.findall( &quot;ASDaDFGAa&quot; ))
#[ a , a ] #列表形式返回匹配到的字符串
pat = re.compile( &quot;[A-Z]+&quot; ) #正则匹配：[A-Z]+ 前一个字符`1`次或无限次扩展
print(pat.findall( &quot;ASDcDFGAa&quot; ))
#[ ASD , DFGA ] #找到匹配到的字符串
pat = re.compile( [A-Z] )
pat.findall( ASDcDFGAa )
[ A , S , D , D , F , G , A ] #找到匹配到的字符串
pat = re.compile( [A-Za-z] ) #正则匹配：[A-Za-z]+ 匹配所有字母
pat.findall( ASDcDFGAa )
[ A , S , D , c , D , F , G , A , a ]
</code></pre>
<h6 id="subpatreplstring-用repl替换-pat匹配项-留的是中间的因为中间在中心">sub(pat,repl,string) ：用repl替换 pat匹配项 (留的是中间的，因为中间在中心)</h6>
<pre><code class="language-python">re.sub( a , A , abcasd ) #找到a用A替换，后面见和group的配合使用
AbcAsd
pat = re.compile( a )
pat.sub( A , abcasd )
AbcAsd
pat=re.compile(r www.(.*)..{3} ) #正则表达式
#在Python的string前面加上‘r’， 是为了告诉编译器这个string是个raw string，不要转译反斜杠
#例如， 在raw string中，是两个字符，和n， 而不会转译为换行符。
#由于正则表达式和 会有冲突，因此，当一个字符串使用了正则表达式后，最好在前面加上 r 。
#与大多数编程语言相同，正则表达式里使用&quot;&quot;作为转义字符，这就可能造成反斜杠困扰。
#假如你需要匹配文本中的字符&quot;&quot;，那么使用编程语言表示的正则表达式里将需要4个反斜杠&quot;\\&quot;：
#前两个和后两个分别用于在编程语言里转义成反斜杠，转换成两个反斜杠后再在正则表达式里转义成一个反斜杠。
#Python里的原生字符串很好地解决了这个问题，这个例子中的正则表达式可以使用r&quot;\&quot;表示。
#同样，匹配一个数字的&quot;\d&quot;可以写成r&quot;d&quot;。
#有了原生字符串，你再也不用担心是不是漏写了反斜杠，写出来的表达式也更直观。
#不是说 加了r 就没有转译功能，好乱，就直接记住1句话：
#当一个字符串使用了正则表达式后，最好在前面加上 r ，这样你再也不用担心是不是漏写了反斜杠，写出来的表达式也更直观
pat.match( www.dxy.com ).group(1)
dxy
re.sub(r www.(.*)..{3} ,r , hello,www.dxy.com )
pat.sub(r , hello,www.dxy.com )
hello,dxy
# r 1 是第一组的意思
#通过正则匹配找到符合规则的&quot;www.dxy.com&quot; ，取得 组1字符串 去替换 整个匹配。
pat=re.compile(r (w+) (w+) ) #正则表达式
s= hello world ! hello hz !
pat.findall( hello world ! hello hz ! )
[( hello , world ), ( hello , hz )]
pat.sub(r ,s) #通过正则得到组1(hello)，组2(world)，再通过sub去替换。
即组1替换组2，组2替换组1，调换位置。
world hello!hz hello!
</code></pre>
<h3 id="xlwt模块">xlwt模块</h3>
<pre><code class="language-python">import xlwt #导入模块
workbook = xlwt.Workbook(encoding='utf-8') #创建workbook 对象
worksheet = workbook.add_sheet('sheet1') #创建工作表sheet
worksheet.write(0, 0, 'hello') #往表中写内容,第一各参数 行,第二个参数列,第三个参数内容
workbook.save('students.xls') #保存表为students.xls
</code></pre>
<p>将九九乘法表显示在表格中，每个单元格1个公式</p>
<pre><code class="language-python">workbook = xlwt.Workbook(encoding='utf-8') #创建workbook 对象
worksheet = workbook.add_sheet('sheet1') #创建工作表sheet
for i in range(0,9):
for j in range(0,i+1):
worksheet.write(i, j, &quot;%d * %d = %d&quot;%(i+1,j+1,(i+1)*(j+1)))
# worksheet.write(0, 0, 'hello') #往表中写内容,第一各参数 行,第二个参数列,第三个参数内容
workbook.save('students.xls') #保存表为students.xls
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://briz-519.github.io/post/hello-gridea/</id>
        <link href="https://briz-519.github.io/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>